# 学习总结：

1、利用axios获取api的数据，方便，这里我把某个页面所用到的api都封装在一个对象中，在这里页面的父组件中应用这个对象，需要哪个api，就用这个对象.(点)定义的方法名即可，这也是实现组件化的一点.

2、组件之间的通信：父传子（props），子传父（emit），eventBus，vuex
兄弟组件之间的通信，有三种方案，eventBus、Vuex、子传父，再父传子，
比较方便的是eventBus，用到一个中间文件eventBus.js

3、eventBus的缺点：
问题：组件A和组件B，当我们还在组件A的时候，组件B若还没生成，也就是组件B中所监听的来自于A中的事件还没有被触发。这个时候当在A中emit事件的时候，B是无法监听的。
分析：vue-router在切换时，先加载新的组件，等新的组件渲染好，但是还没挂载前，再销毁旧的组件，然后再挂载新组件。
解决：组件A的$emit事件应在beforeDestory生命周期内，这样组件B的$on事件就能成功接收到。

4、Vuex应该在庞大的项目并且多涉及到个组件的共享状态情况下，而这里只是两个兄弟组件的共享数据，故不适合用vuex。

5、父组件操作子组件，可以利用ref（指向组件实例），就可以在父组件直接操作子组件的属性
如：需要在父组件中改变 search 子组件中的 data 属性的 ids，
在父组件调用的时候加上 ref：<search @searchById="search" ref="emptyInp"></search>
父组件的操作：this.$refs.emptyInp.ids = '改变的ids值';

6、ES6中Object.assign() 的深浅拷贝，只是一级属性复制，比浅拷贝多深拷贝了一层而已，若是某属性里还有值，且可枚举，就不会对里面的值进行拷贝，而是直接将地址复制，也就是浅拷贝

7、组件复用的问题：（v-for或者重复使用同一个组件）
问题：表格组件复用，当切换的时候，有时报错：_self.$scopedSlots.default is not a function
分析：在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态(例如：表单输入值) 的列表渲染输出。所以，当依赖着子组件的状态，可能就会报这个错误：_self.$scopedSlots.default is not a function
解决：为组件内的每项提供一个 key 值，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素

8、考虑到项目多次使用到loading，故将loading放在axios的拦截器上，在请求拦截器打开loading，在响应拦截器关闭loading，响应成功和失败都要关闭loading
