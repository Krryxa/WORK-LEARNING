# 闭包

1. 变量作用域

- 要理解闭包，首先要理解javascript的特殊的变量作用域。

- 变量的作用域无非就两种：全局变量和局部变量。

- javascript语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。

> 注意点：在函数内部声明变量的时候，一定要使用 var / let / const 命令。如果不用的话，不管在哪里声明，都是一个全局变量！

2. 如何从外部读取函数内部的局部变量？

- 出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。

- 那就是在函数内部，再定义一个函数。
```javascript
function f1 () {
  let n = 999;
  function f2 () {
    alert(n); // 999
　}
}
```
- 在上面的代码中，函数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。
- 这就是Javascript语言特有的"链式作用域"结构（chain scope），

- 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

- 既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，返回到声明的变量，就可以在 f1 外部读取它的内部变量
```javascript
let f1 = (() => {
  let n = 999;
  return () => {
    alert(n); // 999
  };
})();
f1();
```

3. 闭包的概念

- 上面代码中的f2函数，就是闭包。
> 闭包就是：有权访问“另一个函数作用域中的局部变量”的函数

- 闭包可以简单理解成“定义在一个函数内部的函数”

- 所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

4. 闭包的用途

- 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在 f1 调用后被自动清除。

- 为什么会这样呢？原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

- 用闭包解决计数器困境
```javascript
let add = ( () => {
  let counter = 0;
  return () => counter += 1;
})();
// 函数自执行，一开始定义的时候，自我调用了一次，初始化 counter = 0，
// 并且返回一个函数() => {return counter += 1;} 给 add 变量，可调用

add(); // 执行的是 () => {return counter += 1;}
add();
add();
// 计数器为 3

// 变量 add 指定了函数自我调用的返回字值
// 自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。
// add 变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。
// 这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。
// 计数器受匿名函数的作用域保护，只能通过 add 方法修改。
```

5. 使用闭包的注意点（缺点）
- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

- 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

## 闭包面试题
1. 
```js
function a(){
  var n = 0;
  function inc(){
    n++; 
    console.log(n);
  }
  return inc;
}
var c = a();
c();  //控制台输出1
c();  //控制台输出2
```
在这里，控制台两次输出不一样？？？为什么？？变量n不是重新赋值了吗？？

并没有，在这里，var c = a(); 这段代码意思是将 a 方法的返回值赋值给变量 c ，那么 a() 的返回值就是 inc ,也就 function inc() ;

后面执行两次 c(); c(); 实际上是执行两次的  inc(); 因为function一直引用着a()，所以n没有回收，也就是说，n的值一直在引用着;

自然第一次执行 c() 打印1，第二次执行 c() 打印2；


2. 
```js
function createFunctions(){
  var result = [];
  for (var i=0; i < 10; i++){
    result[i] = function(){
      return i;
    };
  }
  return result;
}
var funcs = createFunctions();
for (var i=0; i < funcs.length; i++){
  console.log(funcs[i]()); // 输出十个 10
}
```

3. 经典面试题
```js
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000 * i); // 一开始输出一个5，然后每隔一秒输出一个5，一共五个5
}
```
上面代码一开始输出一个 5（i = 0，定时器的时间 0，延迟执行，所以执行的时候 i=5，所以立刻输出一个5），然后每隔一秒再输出一个 5，一共 5 个 5

- 加上闭包
```js
for (var i = 0; i < 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i);
    }, i * 1000);
  })(i); // 一开始输出一个0，然后每隔一秒输出1 ，2 ，3 ，4
}
```
加上闭包之后，一开始输出一个0，然后每隔一秒输出1 ，2 ，3 ，4，在这里，内部方法引用了外部 i 局部变量，所以 i 的值传递到内部；

- 删掉 i 之后
```js
for (var i = 0; i < 5; i++) {
  (function() {
    setTimeout(function() {
      console.log(i);
    }, i * 1000);
  })(i); // 一开始输出一个 5，然后每隔一秒输出 5 ， 5 ， 5 ， 5，一共 5 个 5
}
```
这样子的话，内部其实没有对 i 保持引用，其实会变成每隔一秒输出 5，一开始输出5，共5个5

- 再改成这样
```js
for (var i = 0; i < 5; i++) {
  setTimeout((function(i) {
    console.log(i);
  })(i), i * 1000);
}
```
这里给 setTimeout 传递了一个立即执行函数。

setTimeout 可以接受函数或者字符串作为参数，那么这里立即执行函数应该是个 undefined ，也就是说等价于：setTimeout(undefined, ...);

而立即执行函数会立即执行，那么应该是立马输出的。

也就是立马输出 0 到 4 